/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createErrorEscapedFromDiscriminatorValue, createGarbage_collectionFromDiscriminatorValue, serializeGarbage_collection, type ErrorEscaped, type Garbage_collection } from '../../../../models/index.js';
// @ts-ignore
import { type WithGarbage_collection_uuItemRequestBuilder, WithGarbage_collection_uuItemRequestBuilderRequestsMetadata } from './item/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GarbageCollectionGetResponse}
 */
// @ts-ignore
export function createGarbageCollectionGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGarbageCollectionGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {GarbageCollectionPostResponse}
 */
// @ts-ignore
export function createGarbageCollectionPostResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoGarbageCollectionPostResponse;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGarbageCollectionGetResponse(garbageCollectionGetResponse: Partial<GarbageCollectionGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "garbage_collection": n => { garbageCollectionGetResponse.garbageCollection = n.getObjectValue<Garbage_collection>(createGarbage_collectionFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoGarbageCollectionPostResponse(garbageCollectionPostResponse: Partial<GarbageCollectionPostResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "garbage_collection": n => { garbageCollectionPostResponse.garbageCollection = n.getObjectValue<Garbage_collection>(createGarbage_collectionFromDiscriminatorValue); },
    }
}
export interface GarbageCollectionGetResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The garbage_collection property
     */
    garbageCollection?: Garbage_collection | null;
}
export interface GarbageCollectionPostResponse extends AdditionalDataHolder, Parsable {
    /**
     * Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.
     */
    additionalData?: Record<string, unknown>;
    /**
     * The garbage_collection property
     */
    garbageCollection?: Garbage_collection | null;
}
/**
 * Builds and executes requests for operations under /v2/registries/{registry_name}/garbage-collection
 */
export interface GarbageCollectionRequestBuilder extends BaseRequestBuilder<GarbageCollectionRequestBuilder> {
    /**
     * Gets an item from the ApiSdk.v2.registries.item.garbageCollection.item collection
     * @param garbage_collection_uuid The UUID of a garbage collection run.
     * @returns {WithGarbage_collection_uuItemRequestBuilder}
     */
     byGarbage_collection_uuid(garbage_collection_uuid: string) : WithGarbage_collection_uuItemRequestBuilder;
    /**
     * To get information about the currently-active garbage collection for a registry, send a GET request to `/v2/registry/$REGISTRY_NAME/garbage-collection`.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<GarbageCollectionGetResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 404 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     get(requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<GarbageCollectionGetResponse | undefined>;
    /**
     * Garbage collection enables users to clear out unreferenced blobs (layer &manifest data) after deleting one or more manifests from a repository. Ifthere are no unreferenced blobs resulting from the deletion of one or moremanifests, garbage collection is effectively a noop.[See here for more information](https://docs.digitalocean.com/products/container-registry/how-to/clean-up-container-registry/)about how and why you should clean up your container registry periodically.To request a garbage collection run on your registry, send a POST request to`/v2/registries/$REGISTRY_NAME/garbage-collection`. This will initiate thefollowing sequence of events on your registry.* Set the registry to read-only mode, meaning no further write-scoped  JWTs will be issued to registry clients. Existing write-scoped JWTs will  continue to work until they expire which can take up to 15 minutes.* Wait until all existing write-scoped JWTs have expired.* Scan all registry manifests to determine which blobs are unreferenced.* Delete all unreferenced blobs from the registry.* Record the number of blobs deleted and bytes freed, mark the garbage  collection status as `success`.* Remove the read-only mode restriction from the registry, meaning write-scoped  JWTs will once again be issued to registry clients.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<GarbageCollectionPostResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 404 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     post(requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<GarbageCollectionPostResponse | undefined>;
    /**
     * To get information about the currently-active garbage collection for a registry, send a GET request to `/v2/registry/$REGISTRY_NAME/garbage-collection`.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
    /**
     * Garbage collection enables users to clear out unreferenced blobs (layer &manifest data) after deleting one or more manifests from a repository. Ifthere are no unreferenced blobs resulting from the deletion of one or moremanifests, garbage collection is effectively a noop.[See here for more information](https://docs.digitalocean.com/products/container-registry/how-to/clean-up-container-registry/)about how and why you should clean up your container registry periodically.To request a garbage collection run on your registry, send a POST request to`/v2/registries/$REGISTRY_NAME/garbage-collection`. This will initiate thefollowing sequence of events on your registry.* Set the registry to read-only mode, meaning no further write-scoped  JWTs will be issued to registry clients. Existing write-scoped JWTs will  continue to work until they expire which can take up to 15 minutes.* Wait until all existing write-scoped JWTs have expired.* Scan all registry manifests to determine which blobs are unreferenced.* Delete all unreferenced blobs from the registry.* Record the number of blobs deleted and bytes freed, mark the garbage  collection status as `success`.* Remove the read-only mode restriction from the registry, meaning write-scoped  JWTs will once again be issued to registry clients.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGarbageCollectionGetResponse(writer: SerializationWriter, garbageCollectionGetResponse: Partial<GarbageCollectionGetResponse> | undefined | null = {}) : void {
    if (garbageCollectionGetResponse) {
        writer.writeObjectValue<Garbage_collection>("garbage_collection", garbageCollectionGetResponse.garbageCollection, serializeGarbage_collection);
        writer.writeAdditionalData(garbageCollectionGetResponse.additionalData);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeGarbageCollectionPostResponse(writer: SerializationWriter, garbageCollectionPostResponse: Partial<GarbageCollectionPostResponse> | undefined | null = {}) : void {
    if (garbageCollectionPostResponse) {
        writer.writeObjectValue<Garbage_collection>("garbage_collection", garbageCollectionPostResponse.garbageCollection, serializeGarbage_collection);
        writer.writeAdditionalData(garbageCollectionPostResponse.additionalData);
    }
}
/**
 * Uri template for the request builder.
 */
export const GarbageCollectionRequestBuilderUriTemplate = "{+baseurl}/v2/registries/{registry_name}/garbage-collection";
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const GarbageCollectionRequestBuilderNavigationMetadata: Record<Exclude<keyof GarbageCollectionRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    byGarbage_collection_uuid: {
        requestsMetadata: WithGarbage_collection_uuItemRequestBuilderRequestsMetadata,
        pathParametersMappings: ["garbage_collection_uuid"],
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const GarbageCollectionRequestBuilderRequestsMetadata: RequestsMetadata = {
    get: {
        uriTemplate: GarbageCollectionRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createGarbageCollectionGetResponseFromDiscriminatorValue,
    },
    post: {
        uriTemplate: GarbageCollectionRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createGarbageCollectionPostResponseFromDiscriminatorValue,
    },
};
/* tslint:enable */
/* eslint-enable */
