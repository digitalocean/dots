/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createErrorEscapedFromDiscriminatorValue, createImageFromDiscriminatorValue, createMeta_propertiesFromDiscriminatorValue, createPage_linksFromDiscriminatorValue, serializeImage, serializeImage_new_custom, serializeMeta_properties, serializePage_links, type ErrorEscaped, type Image, type Image_new_custom, type Meta_properties, type Page_links } from '../../models/index.js';
// @ts-ignore
import { type WithImage_ItemRequestBuilder, WithImage_ItemRequestBuilderNavigationMetadata, WithImage_ItemRequestBuilderRequestsMetadata } from './item/index.js';
// @ts-ignore
import { type BaseRequestBuilder, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImagesGetResponse}
 */
// @ts-ignore
export function createImagesGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImagesGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ImagesPostResponse}
 */
// @ts-ignore
export function createImagesPostResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoImagesPostResponse;
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoImagesGetResponse(imagesGetResponse: Partial<ImagesGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "images": n => { imagesGetResponse.images = n.getCollectionOfObjectValues<Image>(createImageFromDiscriminatorValue); },
        "links": n => { imagesGetResponse.links = n.getObjectValue<Page_links>(createPage_linksFromDiscriminatorValue); },
        "meta": n => { imagesGetResponse.meta = n.getObjectValue<Meta_properties>(createMeta_propertiesFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoImagesPostResponse(imagesPostResponse: Partial<ImagesPostResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "image": n => { imagesPostResponse.image = n.getObjectValue<Image>(createImageFromDiscriminatorValue); },
    }
}
export type GetTypeQueryParameterType = (typeof GetTypeQueryParameterTypeObject)[keyof typeof GetTypeQueryParameterTypeObject];
export interface ImagesGetResponse extends Parsable {
    /**
     * The images property
     */
    images?: Image[] | null;
    /**
     * The links property
     */
    links?: Page_links | null;
    /**
     * The meta property
     */
    meta?: Meta_properties | null;
}
export interface ImagesPostResponse extends Parsable {
    /**
     * The image property
     */
    image?: Image | null;
}
/**
 * Builds and executes requests for operations under /v2/images
 */
export interface ImagesRequestBuilder extends BaseRequestBuilder<ImagesRequestBuilder> {
    /**
     * Gets an item from the dots.v2.images.item collection
     * @param image_id A unique number (id) or string (slug) used to identify and reference aspecific image.**Public** images can be identified by image `id` or `slug`.**Private** images *must* be identified by image `id`.
     * @returns {WithImage_ItemRequestBuilder}
     */
     byImage_id(image_id: number) : WithImage_ItemRequestBuilder;
    /**
     * To list all of the images available on your account, send a GET request to /v2/images.## Filtering Results-----It's possible to request filtered results by including certain query parameters.**Image Type**Either 1-Click Application or OS Distribution images can be filtered by using the `type` query parameter.> Important: The `type` query parameter does not directly relate to the `type` attribute.To retrieve only ***distribution*** images, include the `type` query parameter set to distribution, `/v2/images?type=distribution`.To retrieve only ***application*** images, include the `type` query parameter set to application, `/v2/images?type=application`.**User Images**To retrieve only the private images of a user, include the `private` query parameter set to true, `/v2/images?private=true`.**Tags**To list all images assigned to a specific tag, include the `tag_name` query parameter set to the name of the tag in your GET request. For example, `/v2/images?tag_name=$TAG_NAME`.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<ImagesGetResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     get(requestConfiguration?: RequestConfiguration<ImagesRequestBuilderGetQueryParameters> | undefined) : Promise<ImagesGetResponse | undefined>;
    /**
     * To create a new custom image, send a POST request to /v2/images.The body must contain a url attribute pointing to a Linux virtual machineimage to be imported into DigitalOcean.The image must be in the raw, qcow2, vhdx, vdi, or vmdk format.It may be compressed using gzip or bzip2 and must be smaller than 100 GB after being decompressed.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<ImagesPostResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     post(body: Image_new_custom, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<ImagesPostResponse | undefined>;
    /**
     * To list all of the images available on your account, send a GET request to /v2/images.## Filtering Results-----It's possible to request filtered results by including certain query parameters.**Image Type**Either 1-Click Application or OS Distribution images can be filtered by using the `type` query parameter.> Important: The `type` query parameter does not directly relate to the `type` attribute.To retrieve only ***distribution*** images, include the `type` query parameter set to distribution, `/v2/images?type=distribution`.To retrieve only ***application*** images, include the `type` query parameter set to application, `/v2/images?type=application`.**User Images**To retrieve only the private images of a user, include the `private` query parameter set to true, `/v2/images?private=true`.**Tags**To list all images assigned to a specific tag, include the `tag_name` query parameter set to the name of the tag in your GET request. For example, `/v2/images?tag_name=$TAG_NAME`.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<ImagesRequestBuilderGetQueryParameters> | undefined) : RequestInformation;
    /**
     * To create a new custom image, send a POST request to /v2/images.The body must contain a url attribute pointing to a Linux virtual machineimage to be imported into DigitalOcean.The image must be in the raw, qcow2, vhdx, vdi, or vmdk format.It may be compressed using gzip or bzip2 and must be smaller than 100 GB after being decompressed.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: Image_new_custom, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * To list all of the images available on your account, send a GET request to /v2/images.## Filtering Results-----It's possible to request filtered results by including certain query parameters.**Image Type**Either 1-Click Application or OS Distribution images can be filtered by using the `type` query parameter.> Important: The `type` query parameter does not directly relate to the `type` attribute.To retrieve only ***distribution*** images, include the `type` query parameter set to distribution, `/v2/images?type=distribution`.To retrieve only ***application*** images, include the `type` query parameter set to application, `/v2/images?type=application`.**User Images**To retrieve only the private images of a user, include the `private` query parameter set to true, `/v2/images?private=true`.**Tags**To list all images assigned to a specific tag, include the `tag_name` query parameter set to the name of the tag in your GET request. For example, `/v2/images?tag_name=$TAG_NAME`.
 */
export interface ImagesRequestBuilderGetQueryParameters {
    /**
     * Which 'page' of paginated results to return.
     */
    page?: number;
    /**
     * Number of items returned per page
     */
    perPage?: number;
    /**
     * Used to filter only user images.
     */
    private?: boolean;
    /**
     * Used to filter images by a specific tag.
     */
    tagName?: string;
    /**
     * Filters results based on image type which can be either `application` or `distribution`.
     */
    type?: GetTypeQueryParameterType;
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeImagesGetResponse(writer: SerializationWriter, imagesGetResponse: Partial<ImagesGetResponse> | undefined | null = {}) : void {
    if (imagesGetResponse) {
        writer.writeCollectionOfObjectValues<Image>("images", imagesGetResponse.images, serializeImage);
        writer.writeObjectValue<Page_links>("links", imagesGetResponse.links, serializePage_links);
        writer.writeObjectValue<Meta_properties>("meta", imagesGetResponse.meta, serializeMeta_properties);
    }
}
/**
 * Serializes information the current object
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeImagesPostResponse(writer: SerializationWriter, imagesPostResponse: Partial<ImagesPostResponse> | undefined | null = {}) : void {
    if (imagesPostResponse) {
        writer.writeObjectValue<Image>("image", imagesPostResponse.image, serializeImage);
    }
}
/**
 * Uri template for the request builder.
 */
export const ImagesRequestBuilderUriTemplate = "{+baseurl}/v2/images{?page*,per_page*,private*,tag_name*,type*}";
export const GetTypeQueryParameterTypeObject = {
    Application: "application",
    Distribution: "distribution",
} as const;
/**
 * Mapper for query parameters from symbol name to serialization name represented as a constant.
 */
const ImagesRequestBuilderGetQueryParametersMapper: Record<string, string> = {
    "perPage": "per_page",
    "tagName": "tag_name",
};
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const ImagesRequestBuilderNavigationMetadata: Record<Exclude<keyof ImagesRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    byImage_id: {
        requestsMetadata: WithImage_ItemRequestBuilderRequestsMetadata,
        navigationMetadata: WithImage_ItemRequestBuilderNavigationMetadata,
        pathParametersMappings: ["image_id"],
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const ImagesRequestBuilderRequestsMetadata: RequestsMetadata = {
    get: {
        uriTemplate: ImagesRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createImagesGetResponseFromDiscriminatorValue,
        queryParametersMapper: ImagesRequestBuilderGetQueryParametersMapper,
    },
    post: {
        uriTemplate: ImagesRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createImagesPostResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeImage_new_custom,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
