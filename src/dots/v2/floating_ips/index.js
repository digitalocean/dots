/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createAction_linkFromDiscriminatorValue, createErrorEscapedFromDiscriminatorValue, createFloating_ipFromDiscriminatorValue, createMeta_propertiesFromDiscriminatorValue, createPage_linksFromDiscriminatorValue, deserializeIntoFloating_ip_createMember1, deserializeIntoFloating_ip_createMember2, serializeAction_link, serializeFloating_ip, serializeFloating_ip_createMember1, serializeFloating_ip_createMember2, serializeMeta_properties, serializePage_links } from '../../models/index.js';
// @ts-ignore
import { WithFloating_ipItemRequestBuilderNavigationMetadata, WithFloating_ipItemRequestBuilderRequestsMetadata } from './item/index.js';
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Floating_ip_createMember1 | Floating_ip_createMember2}
 */
// @ts-ignore
export function createFloating_ip_createFromDiscriminatorValue(parseNode) {
    return deserializeIntoFloating_ip_create;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Floating_ipsGetResponse}
 */
// @ts-ignore
export function createFloating_ipsGetResponseFromDiscriminatorValue(parseNode) {
    return deserializeIntoFloating_ipsGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Floating_ipsPostResponse_links}
 */
// @ts-ignore
export function createFloating_ipsPostResponse_linksFromDiscriminatorValue(parseNode) {
    return deserializeIntoFloating_ipsPostResponse_links;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Floating_ipsPostResponse}
 */
// @ts-ignore
export function createFloating_ipsPostResponseFromDiscriminatorValue(parseNode) {
    return deserializeIntoFloating_ipsPostResponse;
}
/**
 * The deserialization information for the current model
 * @param Floating_ip_create The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFloating_ip_create(floating_ip_create = {}) {
    return {
        ...deserializeIntoFloating_ip_createMember1(floating_ip_create),
        ...deserializeIntoFloating_ip_createMember2(floating_ip_create),
    };
}
/**
 * The deserialization information for the current model
 * @param Floating_ipsGetResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFloating_ipsGetResponse(floating_ipsGetResponse = {}) {
    return {
        "floating_ips": n => { floating_ipsGetResponse.floatingIps = n.getCollectionOfObjectValues(createFloating_ipFromDiscriminatorValue); },
        "links": n => { floating_ipsGetResponse.links = n.getObjectValue(createPage_linksFromDiscriminatorValue); },
        "meta": n => { floating_ipsGetResponse.meta = n.getObjectValue(createMeta_propertiesFromDiscriminatorValue); },
    };
}
/**
 * The deserialization information for the current model
 * @param Floating_ipsPostResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFloating_ipsPostResponse(floating_ipsPostResponse = {}) {
    return {
        "floating_ip": n => { floating_ipsPostResponse.floatingIp = n.getObjectValue(createFloating_ipFromDiscriminatorValue); },
        "links": n => { floating_ipsPostResponse.links = n.getObjectValue(createFloating_ipsPostResponse_linksFromDiscriminatorValue); },
    };
}
/**
 * The deserialization information for the current model
 * @param Floating_ipsPostResponse_links The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoFloating_ipsPostResponse_links(floating_ipsPostResponse_links = {}) {
    return {
        "actions": n => { floating_ipsPostResponse_links.actions = n.getCollectionOfObjectValues(createAction_linkFromDiscriminatorValue); },
        "droplets": n => { floating_ipsPostResponse_links.droplets = n.getCollectionOfObjectValues(createAction_linkFromDiscriminatorValue); },
    };
}
/**
 * Serializes information the current object
 * @param Floating_ip_create The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFloating_ip_create(writer, floating_ip_create = {}, isSerializingDerivedType = false) {
    serializeFloating_ip_createMember1(writer, floating_ip_create);
    serializeFloating_ip_createMember2(writer, floating_ip_create);
}
/**
 * Serializes information the current object
 * @param Floating_ipsGetResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFloating_ipsGetResponse(writer, floating_ipsGetResponse = {}, isSerializingDerivedType = false) {
    if (!floating_ipsGetResponse || isSerializingDerivedType) {
        return;
    }
    writer.writeCollectionOfObjectValues("floating_ips", floating_ipsGetResponse.floatingIps, serializeFloating_ip);
    writer.writeObjectValue("links", floating_ipsGetResponse.links, serializePage_links);
    writer.writeObjectValue("meta", floating_ipsGetResponse.meta, serializeMeta_properties);
    writer.writeAdditionalData(floating_ipsGetResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param Floating_ipsPostResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFloating_ipsPostResponse(writer, floating_ipsPostResponse = {}, isSerializingDerivedType = false) {
    if (!floating_ipsPostResponse || isSerializingDerivedType) {
        return;
    }
    writer.writeObjectValue("floating_ip", floating_ipsPostResponse.floatingIp, serializeFloating_ip);
    writer.writeObjectValue("links", floating_ipsPostResponse.links, serializeFloating_ipsPostResponse_links);
    writer.writeAdditionalData(floating_ipsPostResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param Floating_ipsPostResponse_links The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeFloating_ipsPostResponse_links(writer, floating_ipsPostResponse_links = {}, isSerializingDerivedType = false) {
    if (!floating_ipsPostResponse_links || isSerializingDerivedType) {
        return;
    }
    writer.writeCollectionOfObjectValues("actions", floating_ipsPostResponse_links.actions, serializeAction_link);
    writer.writeCollectionOfObjectValues("droplets", floating_ipsPostResponse_links.droplets, serializeAction_link);
    writer.writeAdditionalData(floating_ipsPostResponse_links.additionalData);
}
/**
 * Uri template for the request builder.
 */
export const Floating_ipsRequestBuilderUriTemplate = "{+baseurl}/v2/floating_ips{?page*,per_page*}";
/**
 * Mapper for query parameters from symbol name to serialization name represented as a constant.
 */
const Floating_ipsRequestBuilderGetQueryParametersMapper = {
    "perPage": "per_page",
};
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const Floating_ipsRequestBuilderNavigationMetadata = {
    byFloating_ip: {
        requestsMetadata: WithFloating_ipItemRequestBuilderRequestsMetadata,
        navigationMetadata: WithFloating_ipItemRequestBuilderNavigationMetadata,
        pathParametersMappings: ["floating_ip"],
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const Floating_ipsRequestBuilderRequestsMetadata = {
    get: {
        uriTemplate: Floating_ipsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue,
            429: createErrorEscapedFromDiscriminatorValue,
            500: createErrorEscapedFromDiscriminatorValue,
            XXX: createErrorEscapedFromDiscriminatorValue,
        },
        adapterMethodName: "send",
        responseBodyFactory: createFloating_ipsGetResponseFromDiscriminatorValue,
        queryParametersMapper: Floating_ipsRequestBuilderGetQueryParametersMapper,
    },
    post: {
        uriTemplate: Floating_ipsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue,
            429: createErrorEscapedFromDiscriminatorValue,
            500: createErrorEscapedFromDiscriminatorValue,
            XXX: createErrorEscapedFromDiscriminatorValue,
        },
        adapterMethodName: "send",
        responseBodyFactory: createFloating_ipsPostResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeFloating_ip_create,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
