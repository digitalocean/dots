/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createDatabase_backupFromDiscriminatorValue, createDatabase_cluster_readFromDiscriminatorValue, createErrorEscapedFromDiscriminatorValue, deserializeIntoDatabase_cluster, serializeDatabase_backup, serializeDatabase_cluster, serializeDatabase_cluster_read, type Database_backup, type Database_cluster, type Database_cluster_read, type ErrorEscaped } from '../../models/index.js';
// @ts-ignore
import { type WithDatabase_cluster_uuItemRequestBuilder, WithDatabase_cluster_uuItemRequestBuilderNavigationMetadata, WithDatabase_cluster_uuItemRequestBuilderRequestsMetadata } from './item/index.js';
// @ts-ignore
import { MetricsRequestBuilderNavigationMetadata, type MetricsRequestBuilder } from './metrics/index.js';
// @ts-ignore
import { OptionsRequestBuilderRequestsMetadata, type OptionsRequestBuilder } from './options/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type Guid, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatabasesGetResponse}
 */
// @ts-ignore
export function createDatabasesGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatabasesGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatabasesPostRequestBody}
 */
// @ts-ignore
export function createDatabasesPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatabasesPostRequestBody;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {DatabasesPostResponse}
 */
// @ts-ignore
export function createDatabasesPostResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoDatabasesPostResponse;
}
export interface DatabasesGetResponse extends AdditionalDataHolder, Parsable {
    /**
     * The databases property
     */
    databases?: Database_cluster_read[] | null;
}
export interface DatabasesPostRequestBody extends Database_cluster, Parsable {
    /**
     * The backup_restore property
     */
    backupRestore?: Database_backup | null;
}
export interface DatabasesPostResponse extends AdditionalDataHolder, Parsable {
    /**
     * The database property
     */
    database?: Database_cluster_read | null;
}
/**
 * Builds and executes requests for operations under /v2/databases
 */
export interface DatabasesRequestBuilder extends BaseRequestBuilder<DatabasesRequestBuilder> {
    /**
     * The metrics property
     */
    get metrics(): MetricsRequestBuilder;
    /**
     * The optionsPath property
     */
    get optionsPath(): OptionsRequestBuilder;
    /**
     * Gets an item from the ApiSdk.v2.databases.item collection
     * @param database_cluster_uuid A unique identifier for a database cluster.
     * @returns {WithDatabase_cluster_uuItemRequestBuilder}
     */
     byDatabase_cluster_uuid(database_cluster_uuid: Guid) : WithDatabase_cluster_uuItemRequestBuilder;
    /**
     * To list all of the database clusters available on your account, send a GET request to `/v2/databases`. To limit the results to database clusters with a specific tag, include the `tag_name` query parameter set to the name of the tag. For example, `/v2/databases?tag_name=$TAG_NAME`.The result will be a JSON object with a `databases` key. This will be set to an array of database objects, each of which will contain the standard database attributes.The embedded `connection` and `private_connection` objects will contain the information needed to access the database cluster. For multi-node clusters, the `standby_connection` and `standby_private_connection` objects will contain the information needed to connect to the cluster's standby node(s).The embedded `maintenance_window` object will contain information about any scheduled maintenance for the database cluster.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<DatabasesGetResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 404 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     get(requestConfiguration?: RequestConfiguration<DatabasesRequestBuilderGetQueryParameters> | undefined) : Promise<DatabasesGetResponse | undefined>;
    /**
     * To create a database cluster, send a POST request to `/v2/databases`. To see a list  of options for each engine, such as available regions, size slugs, and versions, send a GET request to the `/v2/databases/options` endpoint. The available sizes for  the `storage_size_mib` field depends on the cluster's size. To see a list of available sizes, see [Managed Database Pricing](https://www.digitalocean.com/pricing/managed-databases).The create response returns a JSON object with a key called `database`. The value of this is an object that contains the standard attributes associated with a database cluster. The initial value of the database cluster's `status` attribute is `creating`. When the cluster is ready to receive traffic, this changes to `online`.The embedded `connection` and `private_connection` objects contains the information needed to access the database cluster. For multi-node clusters, the `standby_connection` and `standby_private_connection` objects contain the information needed to connect to the cluster's standby node(s).DigitalOcean managed PostgreSQL and MySQL database clusters take automated daily backups. To create a new database cluster based on a backup of an existing cluster, send a POST request to `/v2/databases`. In addition to the standard database cluster attributes, the JSON body must include a key named `backup_restore` with the name of the original database cluster and the timestamp of the backup to be restored. Creating a database from a backup is the same as forking a database in the control panel.Note: Caching cluster creates are no longer supported as of 2025-04-30T00:00:00Z. Backups are also not supported for Caching or Valkey clusters.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<DatabasesPostResponse>}
     * @throws {ErrorEscaped} error when the service returns a 401 status code
     * @throws {ErrorEscaped} error when the service returns a 404 status code
     * @throws {ErrorEscaped} error when the service returns a 429 status code
     * @throws {ErrorEscaped} error when the service returns a 500 status code
     * @throws {ErrorEscaped} error when the service returns a 4XX or 5XX status code
     */
     post(body: DatabasesPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<DatabasesPostResponse | undefined>;
    /**
     * To list all of the database clusters available on your account, send a GET request to `/v2/databases`. To limit the results to database clusters with a specific tag, include the `tag_name` query parameter set to the name of the tag. For example, `/v2/databases?tag_name=$TAG_NAME`.The result will be a JSON object with a `databases` key. This will be set to an array of database objects, each of which will contain the standard database attributes.The embedded `connection` and `private_connection` objects will contain the information needed to access the database cluster. For multi-node clusters, the `standby_connection` and `standby_private_connection` objects will contain the information needed to connect to the cluster's standby node(s).The embedded `maintenance_window` object will contain information about any scheduled maintenance for the database cluster.
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<DatabasesRequestBuilderGetQueryParameters> | undefined) : RequestInformation;
    /**
     * To create a database cluster, send a POST request to `/v2/databases`. To see a list  of options for each engine, such as available regions, size slugs, and versions, send a GET request to the `/v2/databases/options` endpoint. The available sizes for  the `storage_size_mib` field depends on the cluster's size. To see a list of available sizes, see [Managed Database Pricing](https://www.digitalocean.com/pricing/managed-databases).The create response returns a JSON object with a key called `database`. The value of this is an object that contains the standard attributes associated with a database cluster. The initial value of the database cluster's `status` attribute is `creating`. When the cluster is ready to receive traffic, this changes to `online`.The embedded `connection` and `private_connection` objects contains the information needed to access the database cluster. For multi-node clusters, the `standby_connection` and `standby_private_connection` objects contain the information needed to connect to the cluster's standby node(s).DigitalOcean managed PostgreSQL and MySQL database clusters take automated daily backups. To create a new database cluster based on a backup of an existing cluster, send a POST request to `/v2/databases`. In addition to the standard database cluster attributes, the JSON body must include a key named `backup_restore` with the name of the original database cluster and the timestamp of the backup to be restored. Creating a database from a backup is the same as forking a database in the control panel.Note: Caching cluster creates are no longer supported as of 2025-04-30T00:00:00Z. Backups are also not supported for Caching or Valkey clusters.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: DatabasesPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * To list all of the database clusters available on your account, send a GET request to `/v2/databases`. To limit the results to database clusters with a specific tag, include the `tag_name` query parameter set to the name of the tag. For example, `/v2/databases?tag_name=$TAG_NAME`.The result will be a JSON object with a `databases` key. This will be set to an array of database objects, each of which will contain the standard database attributes.The embedded `connection` and `private_connection` objects will contain the information needed to access the database cluster. For multi-node clusters, the `standby_connection` and `standby_private_connection` objects will contain the information needed to connect to the cluster's standby node(s).The embedded `maintenance_window` object will contain information about any scheduled maintenance for the database cluster.
 */
export interface DatabasesRequestBuilderGetQueryParameters {
    /**
     * Limits the results to database clusters with a specific tag.<br><br>Requires `tag:read` scope.
     */
    tagName?: string;
}
/**
 * The deserialization information for the current model
 * @param DatabasesGetResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatabasesGetResponse(databasesGetResponse: Partial<DatabasesGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "databases": n => { databasesGetResponse.databases = n.getCollectionOfObjectValues<Database_cluster_read>(createDatabase_cluster_readFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatabasesPostRequestBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatabasesPostRequestBody(databasesPostRequestBody: Partial<DatabasesPostRequestBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoDatabase_cluster(databasesPostRequestBody),
        "backup_restore": n => { databasesPostRequestBody.backupRestore = n.getObjectValue<Database_backup>(createDatabase_backupFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param DatabasesPostResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoDatabasesPostResponse(databasesPostResponse: Partial<DatabasesPostResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "database": n => { databasesPostResponse.database = n.getObjectValue<Database_cluster_read>(createDatabase_cluster_readFromDiscriminatorValue); },
    }
}
/**
 * Serializes information the current object
 * @param DatabasesGetResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatabasesGetResponse(writer: SerializationWriter, databasesGetResponse: Partial<DatabasesGetResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!databasesGetResponse || isSerializingDerivedType) { return; }
    writer.writeCollectionOfObjectValues<Database_cluster_read>("databases", databasesGetResponse.databases, serializeDatabase_cluster_read);
    writer.writeAdditionalData(databasesGetResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param DatabasesPostRequestBody The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatabasesPostRequestBody(writer: SerializationWriter, databasesPostRequestBody: Partial<DatabasesPostRequestBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!databasesPostRequestBody || isSerializingDerivedType) { return; }
    serializeDatabase_cluster(writer, databasesPostRequestBody, isSerializingDerivedType)
    writer.writeObjectValue<Database_backup>("backup_restore", databasesPostRequestBody.backupRestore, serializeDatabase_backup);
}
/**
 * Serializes information the current object
 * @param DatabasesPostResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeDatabasesPostResponse(writer: SerializationWriter, databasesPostResponse: Partial<DatabasesPostResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!databasesPostResponse || isSerializingDerivedType) { return; }
    writer.writeObjectValue<Database_cluster_read>("database", databasesPostResponse.database, serializeDatabase_cluster_read);
    writer.writeAdditionalData(databasesPostResponse.additionalData);
}
/**
 * Uri template for the request builder.
 */
export const DatabasesRequestBuilderUriTemplate = "{+baseurl}/v2/databases{?tag_name*}";
/**
 * Mapper for query parameters from symbol name to serialization name represented as a constant.
 */
const DatabasesRequestBuilderGetQueryParametersMapper: Record<string, string> = {
    "tagName": "tag_name",
};
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const DatabasesRequestBuilderNavigationMetadata: Record<Exclude<keyof DatabasesRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    byDatabase_cluster_uuid: {
        requestsMetadata: WithDatabase_cluster_uuItemRequestBuilderRequestsMetadata,
        navigationMetadata: WithDatabase_cluster_uuItemRequestBuilderNavigationMetadata,
        pathParametersMappings: ["database_cluster_uuid"],
    },
    metrics: {
        navigationMetadata: MetricsRequestBuilderNavigationMetadata,
    },
    optionsPath: {
        requestsMetadata: OptionsRequestBuilderRequestsMetadata,
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const DatabasesRequestBuilderRequestsMetadata: RequestsMetadata = {
    get: {
        uriTemplate: DatabasesRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createDatabasesGetResponseFromDiscriminatorValue,
        queryParametersMapper: DatabasesRequestBuilderGetQueryParametersMapper,
    },
    post: {
        uriTemplate: DatabasesRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            404: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            429: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            500: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
            XXX: createErrorEscapedFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createDatabasesPostResponseFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeDatabasesPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
