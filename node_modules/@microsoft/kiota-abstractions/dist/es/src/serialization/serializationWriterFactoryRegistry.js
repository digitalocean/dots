/** This factory holds a list of all the registered factories for the various types of nodes. */
export class SerializationWriterFactoryRegistry {
    constructor() {
        /**
         * The content type for JSON data.
         */
        this.jsonContentType = "application/json";
        /** List of factories that are registered by content type. */
        this.contentTypeAssociatedFactories = new Map();
    }
    getValidContentType() {
        throw new Error("The registry supports multiple content types. Get the registered factory instead.");
    }
    getSerializationWriter(contentType) {
        if (!contentType) {
            throw new Error("content type cannot be undefined or empty");
        }
        const vendorSpecificContentType = contentType.split(";")[0];
        let factory = this.contentTypeAssociatedFactories.get(vendorSpecificContentType);
        if (factory) {
            return factory.getSerializationWriter(vendorSpecificContentType);
        }
        const cleanedContentType = vendorSpecificContentType.replace(/[^/]+\+/gi, "");
        factory = this.contentTypeAssociatedFactories.get(cleanedContentType);
        if (factory) {
            return factory.getSerializationWriter(cleanedContentType);
        }
        throw new Error(`Content type ${cleanedContentType} does not have a factory registered to be serialized`);
    }
    /**
     * Registers the default serializer to the registry.
     * @param type the class of the factory to be registered.
     */
    registerDefaultSerializer(type) {
        if (!type)
            throw new Error("Type is required");
        const serializer = new type();
        this.contentTypeAssociatedFactories.set(serializer.getValidContentType(), serializer);
    }
    /**
     * Serializes a parsable object into a buffer
     * @param value the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a buffer containing the serialized value
     */
    serializeToJson(value, serializationFunction) {
        return this.serialize(this.jsonContentType, value, serializationFunction);
    }
    /**
     * Serializes a parsable object into a string representation
     * @param value the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeToJsonAsString(value, serializationFunction) {
        return this.serializeToString(this.jsonContentType, value, serializationFunction);
    }
    /**
     * Serializes a collection of parsable objects into a buffer
     * @param values the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeCollectionToJson(values, serializationFunction) {
        return this.serializeCollection(this.jsonContentType, values, serializationFunction);
    }
    /**
     * Serializes a collection of parsable objects into a string representation
     * @param values the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeCollectionToJsonAsString(values, serializationFunction) {
        return this.serializeCollectionToString(this.jsonContentType, values, serializationFunction);
    }
    /**
     * Serializes a parsable object into a buffer
     * @param contentType the content type to serialize to
     * @param value the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a buffer containing the serialized value
     */
    serialize(contentType, value, serializationFunction) {
        const writer = this.getSerializationFactoryWriter(contentType, value, serializationFunction);
        writer.writeObjectValue(undefined, value, serializationFunction);
        return writer.getSerializedContent();
    }
    /**
     * Serializes a parsable object into a string representation
     * @param contentType the content type to serialize to
     * @param value the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeToString(contentType, value, serializationFunction) {
        const buffer = this.serialize(contentType, value, serializationFunction);
        return this.getStringValueFromBuffer(buffer);
    }
    /**
     * Serializes a collection of parsable objects into a buffer
     * @param contentType the content type to serialize to
     * @param values the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeCollection(contentType, values, serializationFunction) {
        const writer = this.getSerializationFactoryWriter(contentType, values, serializationFunction);
        writer.writeCollectionOfObjectValues(undefined, values, serializationFunction);
        return writer.getSerializedContent();
    }
    /**
     * Serializes a collection of parsable objects into a string representation
     * @param contentType the content type to serialize to
     * @param values the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns a string representing the serialized value
     */
    serializeCollectionToString(contentType, values, serializationFunction) {
        const buffer = this.serializeCollection(contentType, values, serializationFunction);
        return this.getStringValueFromBuffer(buffer);
    }
    /**
     * Gets a serialization writer for a given content type
     * @param contentType the content type to serialize to
     * @param value the value to serialize
     * @param serializationFunction the serialization function for the model type
     * @returns the serialization writer for the given content type
     */
    getSerializationFactoryWriter(contentType, value, serializationFunction) {
        if (!contentType) {
            throw new Error("content type cannot be undefined or empty");
        }
        if (!value) {
            throw new Error("value cannot be undefined");
        }
        if (!serializationFunction) {
            throw new Error("serializationFunction cannot be undefined");
        }
        return this.getSerializationWriter(contentType);
    }
    /**
     * Gets a string value from a buffer
     * @param buffer the buffer to get a string from
     * @returns the string representation of the buffer
     */
    getStringValueFromBuffer(buffer) {
        const decoder = new TextDecoder();
        return decoder.decode(buffer);
    }
}
//# sourceMappingURL=serializationWriterFactoryRegistry.js.map