/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
import type { ParseNode } from "./parseNode.js";
import type { ParseNodeFactory } from "./parseNodeFactory.js";
import { Parsable } from "./parsable.js";
import type { ParsableFactory } from "./parsableFactory.js";
import { BackingStoreFactory } from "../store/index.js";
/**
 * This factory holds a list of all the registered factories for the various types of nodes.
 */
export declare class ParseNodeFactoryRegistry implements ParseNodeFactory {
    /**
     * The content type for JSON data.
     */
    private readonly jsonContentType;
    getValidContentType(): string;
    /** List of factories that are registered by content type. */
    contentTypeAssociatedFactories: Map<string, ParseNodeFactory>;
    /**
     * Creates a {@link ParseNode} from the given {@link ArrayBuffer} and content type.
     * @param contentType the content type of the {@link ArrayBuffer}.
     * @param content the {@link ArrayBuffer} to read from.
     * @returns a {@link ParseNode} that can deserialize the given {@link ArrayBuffer}.
     */
    getRootParseNode(contentType: string, content: ArrayBuffer): ParseNode;
    /**
     * Registers the default deserializer to the registry.
     * @param type the class of the factory to be registered.
     * @param backingStoreFactory The backing store factory to use.
     */
    registerDefaultDeserializer(type: new (backingStoreFactory: BackingStoreFactory) => ParseNodeFactory, backingStoreFactory: BackingStoreFactory): void;
    /**
     * Deserializes a buffer into a parsable object
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    deserializeFromJson<T extends Parsable>(bufferOrString: ArrayBuffer | string, factory: ParsableFactory<T>): Parsable;
    /**
     * Deserializes a buffer into a collection of parsable object
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized collection of parsable objects
     */
    deserializeCollectionFromJson<T extends Parsable>(bufferOrString: ArrayBuffer | string, factory: ParsableFactory<T>): T[] | undefined;
    /**
     * Deserializes a buffer into a parsable object
     * @param contentType the content type to serialize to
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    deserialize<T extends Parsable>(contentType: string, bufferOrString: ArrayBuffer | string, factory: ParsableFactory<T>): Parsable;
    /**
     * Deserializes a buffer into a parsable object
     * @param contentType the content type to serialize to
     * @param buffer the value to deserialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    private getParseNode;
    /**
     * Deserializes a buffer into a collection of parsable object
     * @param contentType the content type to serialize to
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized collection of parsable objects
     */
    deserializeCollection<T extends Parsable>(contentType: string, bufferOrString: ArrayBuffer | string, factory: ParsableFactory<T>): T[] | undefined;
    /**
     * Deserializes a buffer into a a collection of parsable object
     * @param value the string to get a buffer from
     * @returns the ArrayBuffer representation of the string
     */
    private getBufferFromString;
}
//# sourceMappingURL=parseNodeFactoryRegistry.d.ts.map