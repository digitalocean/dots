/**
 * This factory holds a list of all the registered factories for the various types of nodes.
 */
export class ParseNodeFactoryRegistry {
    constructor() {
        /**
         * The content type for JSON data.
         */
        this.jsonContentType = "application/json";
        /** List of factories that are registered by content type. */
        this.contentTypeAssociatedFactories = new Map();
    }
    getValidContentType() {
        throw new Error("The registry supports multiple content types. Get the registered factory instead.");
    }
    /**
     * Creates a {@link ParseNode} from the given {@link ArrayBuffer} and content type.
     * @param contentType the content type of the {@link ArrayBuffer}.
     * @param content the {@link ArrayBuffer} to read from.
     * @returns a {@link ParseNode} that can deserialize the given {@link ArrayBuffer}.
     */
    getRootParseNode(contentType, content) {
        if (!contentType) {
            throw new Error("content type cannot be undefined or empty");
        }
        if (!content) {
            throw new Error("content cannot be undefined or empty");
        }
        const vendorSpecificContentType = contentType.split(";")[0];
        let factory = this.contentTypeAssociatedFactories.get(vendorSpecificContentType);
        if (factory) {
            return factory.getRootParseNode(vendorSpecificContentType, content);
        }
        const cleanedContentType = vendorSpecificContentType.replace(/[^/]+\+/gi, "");
        factory = this.contentTypeAssociatedFactories.get(cleanedContentType);
        if (factory) {
            return factory.getRootParseNode(cleanedContentType, content);
        }
        throw new Error(`Content type ${cleanedContentType} does not have a factory registered to be parsed`);
    }
    /**
     * Registers the default deserializer to the registry.
     * @param type the class of the factory to be registered.
     * @param backingStoreFactory The backing store factory to use.
     */
    registerDefaultDeserializer(type, backingStoreFactory) {
        if (!type)
            throw new Error("Type is required");
        const deserializer = new type(backingStoreFactory);
        this.contentTypeAssociatedFactories.set(deserializer.getValidContentType(), deserializer);
    }
    /**
     * Deserializes a buffer into a parsable object
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    deserializeFromJson(bufferOrString, factory) {
        return this.deserialize(this.jsonContentType, bufferOrString, factory);
    }
    /**
     * Deserializes a buffer into a collection of parsable object
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized collection of parsable objects
     */
    deserializeCollectionFromJson(bufferOrString, factory) {
        return this.deserializeCollection(this.jsonContentType, bufferOrString, factory);
    }
    /**
     * Deserializes a buffer into a parsable object
     * @param contentType the content type to serialize to
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    deserialize(contentType, bufferOrString, factory) {
        if (typeof bufferOrString === "string") {
            bufferOrString = this.getBufferFromString(bufferOrString);
        }
        const reader = this.getParseNode(contentType, bufferOrString, factory);
        return reader.getObjectValue(factory);
    }
    /**
     * Deserializes a buffer into a parsable object
     * @param contentType the content type to serialize to
     * @param buffer the value to deserialize
     * @param factory the factory for the model type
     * @returns the deserialized parsable object
     */
    getParseNode(contentType, buffer, factory) {
        if (!contentType) {
            throw new Error("content type cannot be undefined or empty");
        }
        if (!buffer) {
            throw new Error("buffer cannot be undefined");
        }
        if (!factory) {
            throw new Error("factory cannot be undefined");
        }
        return this.getRootParseNode(contentType, buffer);
    }
    /**
     * Deserializes a buffer into a collection of parsable object
     * @param contentType the content type to serialize to
     * @param bufferOrString the value to serialize
     * @param factory the factory for the model type
     * @returns the deserialized collection of parsable objects
     */
    deserializeCollection(contentType, bufferOrString, factory) {
        if (typeof bufferOrString === "string") {
            bufferOrString = this.getBufferFromString(bufferOrString);
        }
        const reader = this.getParseNode(contentType, bufferOrString, factory);
        return reader.getCollectionOfObjectValues(factory);
    }
    /**
     * Deserializes a buffer into a a collection of parsable object
     * @param value the string to get a buffer from
     * @returns the ArrayBuffer representation of the string
     */
    getBufferFromString(value) {
        const encoder = new TextEncoder();
        return encoder.encode(value).buffer;
    }
}
//# sourceMappingURL=parseNodeFactoryRegistry.js.map