import { createGuid } from "./utils/guidUtils.js";
/**
 * Defines an interface for a multipart body for request or response.
 */
export class MultipartBody {
    /**
     * Instantiates a new MultipartBody.
     */
    constructor() {
        this._parts = {};
        this._boundary = createGuid().replace(/-/g, "");
    }
    /**
     * Adds or replaces a part with the given name, content type and content.
     * @param partName the name of the part to add or replace.
     * @param partContentType the content type of the part to add or replace.
     * @param content the content of the part to add or replace.
     * @param serializationCallback the serialization callback to use when serializing the part.
     * @param fileName the name of the file associated with this part.
     */
    addOrReplacePart(partName, partContentType, content, serializationCallback, fileName) {
        if (!partName)
            throw new Error("partName cannot be undefined");
        if (!partContentType) {
            throw new Error("partContentType cannot be undefined");
        }
        if (!content)
            throw new Error("content cannot be undefined");
        const normalizePartName = this.normalizePartName(partName);
        this._parts[normalizePartName] = {
            contentType: partContentType,
            content,
            originalName: partName,
            fileName,
            serializationCallback,
        };
    }
    /**
     * Gets the content of the part with the given name.
     * @param partName the name of the part to get the content for.
     * @returns the content of the part with the given name.
     */
    getPartValue(partName) {
        if (!partName)
            throw new Error("partName cannot be undefined");
        const normalizePartName = this.normalizePartName(partName);
        const candidate = this._parts[normalizePartName];
        if (!candidate)
            return undefined;
        return candidate.content;
    }
    /**
     * Removes the part with the given name.
     * @param partName the name of the part to remove.
     * @returns true if the part was removed, false if it did not exist.
     */
    removePart(partName) {
        if (!partName)
            throw new Error("partName cannot be undefined");
        const normalizePartName = this.normalizePartName(partName);
        if (!this._parts[normalizePartName])
            return false;
        delete this._parts[normalizePartName];
        return true;
    }
    /**
     * Gets the boundary used to separate each part.
     * @returns the boundary value.
     */
    getBoundary() {
        return this._boundary;
    }
    normalizePartName(original) {
        return original.toLocaleLowerCase();
    }
    /**
     * Lists all the parts in the multipart body.
     * WARNING: meant for internal use only
     * @returns the list of parts in the multipart body.
     */
    listParts() {
        return this._parts;
    }
}
export const serializeMultipartBody = (writer, multipartBody = new MultipartBody()) => {
    if (!writer) {
        throw new Error("writer cannot be undefined");
    }
    if (!multipartBody) {
        throw new Error("multipartBody cannot be undefined");
    }
    if (!multipartBody.listParts) {
        throw new Error("multipartBody.listParts cannot be undefined");
    }
    if (!multipartBody.getBoundary) {
        throw new Error("multipartBody.getBoundary cannot be undefined");
    }
    const parts = multipartBody.listParts();
    if (Object.keys(parts).length === 0) {
        throw new Error("multipartBody cannot be empty");
    }
    const boundary = multipartBody.getBoundary();
    let first = true;
    for (const partName in parts) {
        if (Object.prototype.hasOwnProperty.call(parts, partName)) {
            if (first) {
                first = false;
            }
            else {
                writer.writeStringValue(undefined, "\r\n");
            }
            writer.writeStringValue(undefined, "--" + boundary);
            writer.writeStringValue(undefined, "\r\n");
            const part = parts[partName];
            writer.writeStringValue("Content-Type", part.contentType);
            writer.writeStringValue(undefined, "\r\n");
            writer.writeStringValue("Content-Disposition", `form-data; name="${part.originalName}"${part.fileName ? `; filename="${part.fileName}"` : ""}`);
            writer.writeStringValue(undefined, "\r\n");
            writer.writeStringValue(undefined, "\r\n");
            if (typeof part.content === "string") {
                writer.writeStringValue(undefined, part.content);
            }
            else if (part.content instanceof ArrayBuffer) {
                writer.writeByteArrayValue(undefined, new Uint8Array(part.content));
            }
            else if (part.content instanceof Uint8Array) {
                writer.writeByteArrayValue(undefined, part.content);
            }
            else if (part.serializationCallback) {
                if (!multipartBody.requestAdapter) {
                    throw new Error("requestAdapter cannot be undefined");
                }
                const serializationWriterFactory = multipartBody.requestAdapter.getSerializationWriterFactory();
                if (!serializationWriterFactory) {
                    throw new Error("serializationWriterFactory cannot be undefined");
                }
                const partSerializationWriter = serializationWriterFactory.getSerializationWriter(part.contentType);
                if (!partSerializationWriter) {
                    throw new Error("no serialization writer factory for content type: " + part.contentType);
                }
                partSerializationWriter.writeObjectValue(undefined, part.content, part.serializationCallback);
                const partContent = partSerializationWriter.getSerializedContent();
                writer.writeByteArrayValue(undefined, new Uint8Array(partContent));
            }
            else {
                throw new Error("unsupported content type for multipart body: " + typeof part.content);
            }
        }
    }
    writer.writeStringValue(undefined, "\r\n");
    writer.writeStringValue(undefined, "--" + boundary + "--");
    writer.writeStringValue(undefined, "\r\n");
};
export const deserializeIntoMultipartBody = (_ = new MultipartBody()) => {
    throw new Error("Not implemented");
};
export const createMessageFromDiscriminatorValue = (parseNode) => {
    if (!parseNode)
        throw new Error("parseNode cannot be undefined");
    return deserializeIntoMultipartBody;
};
//# sourceMappingURL=multipartBody.js.map