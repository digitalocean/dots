/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/**
 * Maintains a list of valid hosts and allows authentication providers to
 * check whether a host is valid before authenticating a request
 */
export class AllowedHostsValidator {
    /**
     * Creates a new AllowedHostsValidator object with provided values.
     * @param allowedHosts A list of valid hosts.  If the list is empty, all hosts are valid.
     */
    constructor(allowedHosts = new Set()) {
        this.validateHosts(allowedHosts);
        this.allowedHosts = allowedHosts !== null && allowedHosts !== void 0 ? allowedHosts : new Set();
    }
    /**
     * Gets the list of valid hosts.  If the list is empty, all hosts are valid.
     * @returns A list of valid hosts.  If the list is empty, all hosts are valid.
     */
    getAllowedHosts() {
        return Array.from(this.allowedHosts);
    }
    /**
     * Sets the list of valid hosts.  If the list is empty, all hosts are valid.
     * @param allowedHosts A list of valid hosts.  If the list is empty, all hosts are valid.
     */
    setAllowedHosts(allowedHosts) {
        this.validateHosts(allowedHosts);
        this.allowedHosts = allowedHosts;
    }
    /**
     * Checks whether the provided host is valid.
     * @param url The url to check.
     * @returns True if the host is valid, false otherwise.
     */
    isUrlHostValid(url) {
        var _a, _b;
        if (!url)
            return false;
        if (this.allowedHosts.size === 0)
            return true;
        const schemeAndRest = url.split("://");
        if (schemeAndRest.length >= 2) {
            const rest = schemeAndRest[1];
            if (rest) {
                return this.isHostAndPathValid(rest);
            }
        }
        else if (!url.startsWith("http")) {
            // protocol relative URL domain.tld/path
            return this.isHostAndPathValid(url);
        }
        if ((_a = window === null || window === void 0 ? void 0 : window.location) === null || _a === void 0 ? void 0 : _a.host) {
            return this.allowedHosts.has((_b = window.location.host) === null || _b === void 0 ? void 0 : _b.toLowerCase());
        }
        return false;
    }
    isHostAndPathValid(rest) {
        const hostAndRest = rest.split("/");
        if (hostAndRest.length >= 2) {
            const host = hostAndRest[0];
            if (host) {
                return this.allowedHosts.has(host.toLowerCase());
            }
        }
        return false;
    }
    validateHosts(hostsToValidate) {
        if (!hostsToValidate) {
            throw new Error("hostsToValidate cannot be null");
        }
        hostsToValidate.forEach((host) => {
            if (host.toLowerCase().startsWith("http://") || host.toLowerCase().startsWith("https://")) {
                throw new Error("host should not contain http or https prefix");
            }
        });
    }
}
//# sourceMappingURL=allowedHostsValidator.js.map