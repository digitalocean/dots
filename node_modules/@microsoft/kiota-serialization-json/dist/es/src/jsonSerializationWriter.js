/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/* eslint-disable @typescript-eslint/no-unused-expressions */
import { DateOnly, Duration, isUntypedNode, TimeOnly, isUntypedBoolean, isUntypedString, isUntypedNull, isUntypedNumber, isUntypedObject, isUntypedArray, inNodeEnv } from "@microsoft/kiota-abstractions";
export class JsonSerializationWriter {
    constructor() {
        this.writer = [];
        this.shouldWriteValueOrNull = (key, value) => {
            if (value === null) {
                this.writeNullValue(key);
                return false;
            }
            return true;
        };
        this.writeStringValue = (key, value) => {
            if (value === undefined) {
                return;
            }
            if (this.shouldWriteValueOrNull(key, value)) {
                key && this.writePropertyName(key);
                this.writer.push(JSON.stringify(value));
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writePropertyName = (key) => {
            this.writer.push(`"${key}":`);
        };
        this.writeBooleanValue = (key, value) => {
            if (value === undefined) {
                return;
            }
            if (this.shouldWriteValueOrNull(key, value)) {
                key && this.writePropertyName(key);
                this.writer.push(`${value}`);
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeNumberValue = (key, value) => {
            if (value === undefined) {
                return;
            }
            if (this.shouldWriteValueOrNull(key, value)) {
                key && this.writePropertyName(key);
                this.writer.push(`${value}`);
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeGuidValue = (key, value) => {
            if (value === undefined) {
                return;
            }
            if (this.shouldWriteValueOrNull(key, value)) {
                key && this.writePropertyName(key);
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                this.writer.push(`"${value}"`);
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeDateValue = (key, value) => this.writeStringValue(key, value === null ? null : value === null || value === void 0 ? void 0 : value.toISOString());
        this.writeDateOnlyValue = (key, value) => this.writeStringValue(key, value === null ? null : value === null || value === void 0 ? void 0 : value.toString());
        this.writeTimeOnlyValue = (key, value) => this.writeStringValue(key, value === null ? null : value === null || value === void 0 ? void 0 : value.toString());
        this.writeDurationValue = (key, value) => this.writeStringValue(key, value === null ? null : value === null || value === void 0 ? void 0 : value.toString());
        this.writeNullValue = (key) => {
            key && this.writePropertyName(key);
            this.writer.push(`null`);
            key && this.writer.push(JsonSerializationWriter.propertySeparator);
        };
        this.writeCollectionOfPrimitiveValues = (key, values) => {
            if (!this.shouldWriteValueOrNull(key, values)) {
                return;
            }
            if (values) {
                key && this.writePropertyName(key);
                this.startArray();
                values.forEach((v, idx) => {
                    this.writeAnyValue(undefined, v);
                    idx + 1 < values.length && this.writer.push(JsonSerializationWriter.propertySeparator);
                });
                this.endArray();
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.writeCollectionOfObjectValues = (key, values, serializerMethod) => {
            if (!this.shouldWriteValueOrNull(key, values)) {
                return;
            }
            if (values) {
                key && this.writePropertyName(key);
                this.startArray();
                values.forEach((v) => {
                    this.writeObjectValue(undefined, v, serializerMethod);
                    this.writer.push(JsonSerializationWriter.propertySeparator);
                });
                if (values.length > 0) {
                    // removing the last separator
                    this.writer.pop();
                }
                this.endArray();
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.startObject = () => {
            this.writer.push(`{`);
        };
        this.endObject = () => {
            this.writer.push(`}`);
        };
        this.startArray = () => {
            this.writer.push(`[`);
        };
        this.endArray = () => {
            this.writer.push(`]`);
        };
        this.removeLastSeparator = () => {
            if (this.writer.length > 0 && this.writer[this.writer.length - 1] === JsonSerializationWriter.propertySeparator) {
                this.writer.pop();
            }
        };
        this.writeEnumValue = (key, ...values) => {
            if (values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const rawValues = values.filter((x) => x !== undefined).map((x) => `${x}`);
                if (rawValues.length > 0) {
                    this.writeStringValue(key, rawValues.reduce((x, y) => `${x}, ${y}`));
                }
            }
        };
        this.writeCollectionOfEnumValues = (key, values) => {
            if (values && values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const rawValues = values.filter((x) => x !== undefined).map((x) => `${x}`);
                if (rawValues.length === 0) {
                    return;
                }
                key && this.writePropertyName(key);
                this.writer.push(JSON.stringify(rawValues));
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
        };
        this.getSerializedContent = () => {
            return this.convertStringToArrayBuffer(this.writer.join(``));
        };
        this.convertStringToArrayBuffer = (str) => {
            const encoder = new TextEncoder();
            const encodedString = encoder.encode(str);
            return encodedString.buffer;
        };
        this.writeAdditionalData = (additionalData) => {
            // !value will fail to serialize false and null values which can be valid input
            if (additionalData === undefined)
                return;
            for (const key in additionalData) {
                if (Object.prototype.hasOwnProperty.call(additionalData, key)) {
                    this.writeAnyValue(key, additionalData[key]);
                }
            }
        };
        this.writeNonParsableObjectValue = (key, value) => {
            if (key) {
                this.writePropertyName(key);
            }
            this.writer.push(JSON.stringify(value), JsonSerializationWriter.propertySeparator);
        };
        // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
        this.writeAnyValue = (key, value) => {
            if (value === undefined) {
                return;
            }
            if (!this.shouldWriteValueOrNull(key, value)) {
                return;
            }
            const valueType = typeof value;
            if (valueType === "boolean") {
                this.writeBooleanValue(key, value);
            }
            else if (valueType === "string") {
                this.writeStringValue(key, value);
            }
            else if (value instanceof Date) {
                this.writeDateValue(key, value);
            }
            else if (value instanceof DateOnly) {
                this.writeDateOnlyValue(key, value);
            }
            else if (value instanceof TimeOnly) {
                this.writeTimeOnlyValue(key, value);
            }
            else if (value instanceof Duration) {
                this.writeDurationValue(key, value);
            }
            else if (valueType === "number") {
                this.writeNumberValue(key, value);
            }
            else if (Array.isArray(value)) {
                this.writeCollectionOfPrimitiveValues(key, value);
            }
            else if (valueType === "object") {
                this.writeNonParsableObjectValue(key, value);
            }
            else {
                throw new Error(`encountered unknown value type during serialization ${valueType}`);
            }
        };
    }
    writeByteArrayValue(key, value) {
        if (!value) {
            return;
        }
        const b64 = inNodeEnv() ? Buffer.from(value).toString("base64") : btoa(new TextDecoder().decode(value));
        this.writeStringValue(key, b64);
    }
    writeObjectValue(key, value, serializerMethod) {
        if (value === undefined) {
            return;
        }
        if (!this.shouldWriteValueOrNull(key, value)) {
            return;
        }
        if (isUntypedNode(value)) {
            const untypedNode = value;
            if (isUntypedBoolean(untypedNode)) {
                this.writeBooleanValue(key, untypedNode.getValue());
            }
            else if (isUntypedString(untypedNode)) {
                this.writeStringValue(key, untypedNode.getValue());
            }
            else if (isUntypedNull(untypedNode)) {
                this.writeNullValue(key);
            }
            else if (isUntypedNumber(untypedNode)) {
                this.writeNumberValue(key, untypedNode.getValue());
            }
            else if (isUntypedObject(untypedNode)) {
                const objectValue = untypedNode.getValue();
                if (objectValue === undefined)
                    return;
                if (key)
                    this.writePropertyName(key);
                this.startObject();
                for (const vKey in objectValue) {
                    if (Object.prototype.hasOwnProperty.call(objectValue, vKey)) {
                        this.writeObjectValue(vKey, objectValue[vKey], serializerMethod);
                    }
                }
                this.removeLastSeparator();
                this.endObject();
                if (key)
                    this.writer.push(JsonSerializationWriter.propertySeparator);
            }
            else if (isUntypedArray(untypedNode)) {
                if (key) {
                    this.writePropertyName(key);
                }
                const arrValue = untypedNode.getValue();
                this.startArray();
                arrValue.forEach((v, idx) => {
                    this.writeObjectValue(undefined, v, serializerMethod);
                    idx + 1 < arrValue.length && this.writer.push(JsonSerializationWriter.propertySeparator);
                });
                this.removeLastSeparator();
                this.endArray();
                key && this.writer.push(JsonSerializationWriter.propertySeparator);
            }
            else {
                this.writeAnyValue(key, untypedNode.getValue());
            }
            return; // nothing to do here, the value has been written
        }
        if (key)
            this.writePropertyName(key);
        this.onBeforeObjectSerialization && this.onBeforeObjectSerialization(value);
        this.startObject();
        this.onStartObjectSerialization && this.onStartObjectSerialization(value, this);
        serializerMethod && serializerMethod(this, value);
        this.onAfterObjectSerialization && this.onAfterObjectSerialization(value);
        this.removeLastSeparator();
        this.endObject();
        if (key)
            this.writer.push(JsonSerializationWriter.propertySeparator);
    }
}
JsonSerializationWriter.propertySeparator = `,`;
//# sourceMappingURL=jsonSerializationWriter.js.map