/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
import { type AuthenticationProvider, type BackingStoreFactory, InMemoryBackingStoreFactory, type ErrorMappings, type Parsable, type ParsableFactory, type ParseNodeFactory, type PrimitiveTypesForDeserialization, type PrimitiveTypesForDeserializationType, type RequestAdapter, type RequestInformation, type SerializationWriterFactory } from "@microsoft/kiota-abstractions";
import { HttpClient } from "./httpClient.js";
import { type ObservabilityOptions } from "./observabilityOptions.js";
/**
 * Request adapter implementation for the fetch API.
 */
export declare class FetchRequestAdapter implements RequestAdapter {
    readonly authenticationProvider: AuthenticationProvider;
    private parseNodeFactory;
    private serializationWriterFactory;
    private readonly httpClient;
    private backingStoreFactory;
    /** The base url for every request. */
    baseUrl: string;
    getSerializationWriterFactory(): SerializationWriterFactory;
    getParseNodeFactory(): ParseNodeFactory;
    getBackingStoreFactory(): BackingStoreFactory;
    private readonly observabilityOptions;
    /**
     * Instantiates a new request adapter.
     * @param authenticationProvider the authentication provider to use.
     * @param parseNodeFactory the parse node factory to deserialize responses.
     * @param serializationWriterFactory the serialization writer factory to use to serialize request bodies.
     * @param httpClient the http client to use to execute requests.
     * @param observabilityOptions the observability options to use.
     * @param backingStoreFactory the backing store factory to use.
     */
    constructor(authenticationProvider: AuthenticationProvider, parseNodeFactory?: ParseNodeFactory, serializationWriterFactory?: SerializationWriterFactory, httpClient?: HttpClient, observabilityOptions?: ObservabilityOptions, backingStoreFactory?: InMemoryBackingStoreFactory);
    private readonly getResponseContentType;
    private readonly getResponseHandler;
    private static readonly responseTypeAttributeKey;
    sendCollectionOfPrimitive: <ResponseType extends Exclude<PrimitiveTypesForDeserializationType, ArrayBuffer>>(requestInfo: RequestInformation, responseType: Exclude<PrimitiveTypesForDeserialization, "ArrayBuffer">, errorMappings: ErrorMappings | undefined) => Promise<ResponseType[] | undefined>;
    sendCollection: <ModelType extends Parsable>(requestInfo: RequestInformation, deserialization: ParsableFactory<ModelType>, errorMappings: ErrorMappings | undefined) => Promise<ModelType[] | undefined>;
    private readonly startTracingSpan;
    static readonly eventResponseHandlerInvokedKey = "com.microsoft.kiota.response_handler_invoked";
    send: <ModelType extends Parsable>(requestInfo: RequestInformation, deserializer: ParsableFactory<ModelType>, errorMappings: ErrorMappings | undefined) => Promise<ModelType | undefined>;
    sendPrimitive: <ResponseType extends PrimitiveTypesForDeserializationType>(requestInfo: RequestInformation, responseType: PrimitiveTypesForDeserialization, errorMappings: ErrorMappings | undefined) => Promise<ResponseType | undefined>;
    sendNoResponseContent: (requestInfo: RequestInformation, errorMappings: ErrorMappings | undefined) => Promise<void>;
    sendEnum: <EnumObject extends Record<string, unknown>>(requestInfo: RequestInformation, enumObject: EnumObject, errorMappings: ErrorMappings | undefined) => Promise<EnumObject[keyof EnumObject] | undefined>;
    sendCollectionOfEnum: <EnumObject extends Record<string, unknown>>(requestInfo: RequestInformation, enumObject: EnumObject, errorMappings: ErrorMappings | undefined) => Promise<EnumObject[keyof EnumObject][] | undefined>;
    enableBackingStore: (backingStoreFactory?: BackingStoreFactory) => void;
    private readonly getRootParseNode;
    private readonly shouldReturnUndefined;
    /**
     * purges the response body if it hasn't been read to release the connection to the server
     * @param response the response to purge
     */
    private readonly purgeResponseBody;
    static readonly errorMappingFoundAttributeName = "com.microsoft.kiota.error.mapping_found";
    static readonly errorBodyFoundAttributeName = "com.microsoft.kiota.error.body_found";
    private static readonly locationHeaderName;
    private readonly throwIfFailedResponse;
    private readonly getHttpResponseMessage;
    static readonly authenticateChallengedEventKey = "com.microsoft.kiota.authenticate_challenge_received";
    private readonly retryCAEResponseIfRequired;
    private readonly getClaimsFromResponse;
    private readonly setBaseUrlForRequestInformation;
    private readonly getRequestFromRequestInformation;
    private readonly foldHeaderValue;
    /**
     * @inheritdoc
     */
    convertToNativeRequest: <T>(requestInfo: RequestInformation) => Promise<T>;
}
//# sourceMappingURL=fetchRequestAdapter.d.ts.map