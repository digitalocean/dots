/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
import { trace } from "@opentelemetry/api";
import { getObservabilityOptionsFromRequest } from "../observabilityOptions.js";
import { ParametersNameDecodingHandlerOptions, ParametersNameDecodingHandlerOptionsKey } from "./options/parametersNameDecodingOptions.js";
/**
 * @module ParametersNameDecodingHandler
 */
export class ParametersNameDecodingHandler {
    /**
     *
     * To create an instance of ParametersNameDecodingHandler
     * @param [options] - The parameters name decoding handler options value
     */
    constructor(options = new ParametersNameDecodingHandlerOptions()) {
        this.options = options;
        if (!options) {
            throw new Error("The options parameter is required.");
        }
    }
    /**
     * To execute the current middleware
     * @param url - The url to be fetched
     * @param requestInit - The request init object
     * @param requestOptions - The request options
     * @returns A Promise that resolves to nothing
     */
    execute(url, requestInit, requestOptions) {
        let currentOptions = this.options;
        if (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions[ParametersNameDecodingHandlerOptionsKey]) {
            currentOptions = requestOptions[ParametersNameDecodingHandlerOptionsKey];
        }
        const obsOptions = getObservabilityOptionsFromRequest(requestOptions);
        if (obsOptions) {
            return trace.getTracer(obsOptions.getTracerInstrumentationName()).startActiveSpan("parametersNameDecodingHandler - execute", (span) => {
                try {
                    span.setAttribute("com.microsoft.kiota.handler.parameters_name_decoding.enable", currentOptions.enable);
                    return this.decodeParameters(url, requestInit, currentOptions, requestOptions);
                }
                finally {
                    span.end();
                }
            });
        }
        return this.decodeParameters(url, requestInit, currentOptions, requestOptions);
    }
    decodeParameters(url, requestInit, currentOptions, requestOptions) {
        var _a, _b;
        let updatedUrl = url;
        if (currentOptions && currentOptions.enable && url.includes("%") && currentOptions.charactersToDecode && currentOptions.charactersToDecode.length > 0) {
            currentOptions.charactersToDecode.forEach((character) => {
                updatedUrl = updatedUrl.replace(new RegExp(`%${character.charCodeAt(0).toString(16)}`, "gi"), character);
            });
        }
        return (_b = (_a = this.next) === null || _a === void 0 ? void 0 : _a.execute(updatedUrl, requestInit, requestOptions)) !== null && _b !== void 0 ? _b : Promise.reject(new Error("The next middleware is not set."));
    }
}
//# sourceMappingURL=parametersNameDecodingHandler.js.map