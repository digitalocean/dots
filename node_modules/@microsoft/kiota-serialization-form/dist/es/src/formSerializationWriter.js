/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/* eslint-disable @typescript-eslint/no-unused-expressions */
import { DateOnly, Duration, TimeOnly } from "@microsoft/kiota-abstractions";
export class FormSerializationWriter {
    constructor() {
        this.writer = [];
        this.depth = -1;
        this.writeStringValue = (key, value) => {
            if (value === null) {
                value = "null";
            }
            if (key && value) {
                this.writePropertyName(key);
                this.writer.push(`=${encodeURIComponent(value)}`);
                this.writer.push(FormSerializationWriter.propertySeparator);
            }
        };
        this.writePropertyName = (key) => {
            this.writer.push(encodeURIComponent(key));
        };
        this.shouldWriteValueOrNull = (key, value) => {
            if (value === null) {
                this.writeNullValue(key);
                return false;
            }
            return true;
        };
        this.writeBooleanValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value !== undefined && this.writeStringValue(key, `${value}`);
            }
        };
        this.writeNumberValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, `${value}`);
            }
        };
        this.writeGuidValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, value.toString());
            }
        };
        this.writeDateValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, value.toISOString());
            }
        };
        this.writeDateOnlyValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, value.toString());
            }
        };
        this.writeTimeOnlyValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, value.toString());
            }
        };
        this.writeDurationValue = (key, value) => {
            if (this.shouldWriteValueOrNull(key, value)) {
                value && this.writeStringValue(key, value.toString());
            }
        };
        this.writeNullValue = (key) => {
            key && this.writeStringValue(key, null);
        };
        this.writeCollectionOfPrimitiveValues = (_key, _values) => {
            if (_key && _values) {
                _values.forEach((val) => {
                    this.writeAnyValue(_key, val);
                });
            }
        };
        this.writeCollectionOfObjectValues = (_key, _values) => {
            throw new Error(`serialization of collections is not supported with URI encoding`);
        };
        this.writeObjectValue = (key, value, serializerMethod) => {
            if (++this.depth > 0) {
                throw new Error(`serialization of nested objects is not supported with URI encoding`);
            }
            if (!this.shouldWriteValueOrNull(key, value)) {
                return;
            }
            if (value) {
                if (key) {
                    this.writePropertyName(key);
                }
                this.onBeforeObjectSerialization && this.onBeforeObjectSerialization(value);
                this.onStartObjectSerialization && this.onStartObjectSerialization(value, this);
                serializerMethod(this, value);
                this.onAfterObjectSerialization && this.onAfterObjectSerialization(value);
                if (this.writer.length > 0 && this.writer[this.writer.length - 1] === FormSerializationWriter.propertySeparator) {
                    // removing the last separator
                    this.writer.pop();
                }
                key && this.writer.push(FormSerializationWriter.propertySeparator);
            }
        };
        this.writeEnumValue = (key, ...values) => {
            if (values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const rawValues = values.filter((x) => x !== undefined).map((x) => `${x}`);
                if (rawValues.length > 0) {
                    this.writeStringValue(key, rawValues.reduce((x, y) => `${x}, ${y}`));
                }
            }
        };
        this.writeCollectionOfEnumValues = (key, values) => {
            if (key && values && values.length > 0) {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                const rawValues = values.filter((x) => x !== undefined).map((x) => `${x}`);
                if (rawValues.length > 0) {
                    this.writeCollectionOfPrimitiveValues(key, rawValues);
                }
            }
        };
        this.getSerializedContent = () => {
            return this.convertStringToArrayBuffer(this.writer.join(``));
        };
        this.convertStringToArrayBuffer = (str) => {
            const encoder = new TextEncoder();
            const encodedString = encoder.encode(str);
            return encodedString.buffer;
        };
        this.writeAdditionalData = (additionalData) => {
            // Do not use !value here, because value can be `false`.
            if (additionalData === undefined)
                return;
            // eslint-disable-next-line guard-for-in
            for (const key in additionalData) {
                this.writeAnyValue(key, additionalData[key]);
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
        this.writeAnyValue = (key, value) => {
            if (value === null) {
                return this.writeNullValue(key);
            }
            if (value !== undefined) {
                const valueType = typeof value;
                if (valueType === "boolean") {
                    this.writeBooleanValue(key, value);
                }
                else if (valueType === "string") {
                    this.writeStringValue(key, value);
                }
                else if (value instanceof Date) {
                    this.writeDateValue(key, value);
                }
                else if (value instanceof DateOnly) {
                    this.writeDateOnlyValue(key, value);
                }
                else if (value instanceof TimeOnly) {
                    this.writeTimeOnlyValue(key, value);
                }
                else if (value instanceof Duration) {
                    this.writeDurationValue(key, value);
                }
                else if (valueType === "number") {
                    this.writeNumberValue(key, value);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-base-to-string, @typescript-eslint/restrict-template-expressions
                    throw new Error(`encountered unknown ${value} value type during serialization ${valueType} for key ${key}`);
                }
            }
        };
    }
    writeByteArrayValue(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    key, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    value) {
        throw new Error("serialization of byt arrays is not supported with URI encoding");
    }
}
FormSerializationWriter.propertySeparator = `&`;
//# sourceMappingURL=formSerializationWriter.js.map