/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
import { DateOnly, Duration, parseGuidString, TimeOnly, inNodeEnv, getEnumValueFromStringValue } from "@microsoft/kiota-abstractions";
/**
 * This class represents a text parse node.
 */
export class TextParseNode {
    constructor(text) {
        this.text = text;
        this.getStringValue = () => this.text;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getChildNode = (identifier) => {
            throw new Error(TextParseNode.noStructuredDataMessage);
        };
        this.getBooleanValue = () => {
            var _a;
            const value = (_a = this.getStringValue()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (value === "true" || value === "1") {
                return true;
            }
            else if (value === "false" || value === "0") {
                return false;
            }
            return undefined;
        };
        this.getNumberValue = () => Number(this.text);
        this.getGuidValue = () => parseGuidString(this.text);
        this.getDateValue = () => new Date(Date.parse(this.text));
        this.getDateOnlyValue = () => DateOnly.parse(this.getStringValue());
        this.getTimeOnlyValue = () => TimeOnly.parse(this.getStringValue());
        this.getDurationValue = () => Duration.parse(this.getStringValue());
        this.getCollectionOfPrimitiveValues = () => {
            throw new Error(TextParseNode.noStructuredDataMessage);
        };
        this.getCollectionOfEnumValues = (type) => {
            throw new Error(TextParseNode.noStructuredDataMessage);
        };
        this.getEnumValue = (type) => {
            const rawValue = this.getStringValue();
            if (!rawValue) {
                return undefined;
            }
            return getEnumValueFromStringValue(rawValue, type);
        };
        if (this.text && this.text.length > 1 && this.text.startsWith('"') && this.text.endsWith('"')) {
            this.text = this.text.substring(1, this.text.length - 2);
        }
    }
    getByteArrayValue() {
        const strValue = this.getStringValue();
        if (strValue && strValue.length > 0) {
            /**
             * Node.js Buffer objects created via Buffer.from() use a shared memory pool
             * and may be subject to reuse/recycling, which can lead to unexpected behavior.
             *
             * For consistent behavior across environments:
             * - In Node: We convert the base64 string to a Buffer first, then create a new
             *   Uint8Array from it to ensure we have a stable, independent copy
             * - In browsers: We convert the string directly using TextEncoder
             *
             * TODO: Consider standardizing on a cross-platform UInt8Array.fromBase64 (after the API is stabilized across browsers)
             * in the future instead of the current environment-specific approach
             */
            return inNodeEnv() ? new Uint8Array(Buffer.from(strValue, "base64")).buffer : new TextEncoder().encode(strValue);
        }
        return undefined;
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    getCollectionOfObjectValues(parsableFactory) {
        throw new Error(TextParseNode.noStructuredDataMessage);
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    getObjectValue(parsableFactory) {
        throw new Error(TextParseNode.noStructuredDataMessage);
    }
}
TextParseNode.noStructuredDataMessage = "text does not support structured data";
//# sourceMappingURL=textParseNode.js.map